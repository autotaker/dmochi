(* horsat killer example *)

let next : [Bool,Bool,Bool,Bool,Bool] -> [Bool,Bool,Bool,Bool,Bool] =
    fun (cur : [Bool,Bool,Bool,Bool,Bool]) ->
      (assume not cur.(0/5);
          (5 (not cur.(0/5)) cur.(1/5) cur.(2/5) cur.(3/5) cur.(4/5))) <>
      (assume cur.(0/5) && not cur.(1/5);
          (5 (not cur.(0/5)) (not cur.(1/5)) cur.(2/5) cur.(3/5) cur.(4/5))) <>
      (assume cur.(0/5) && cur.(1/5) && not cur.(2/5);
          (5 (not cur.(0/5)) (not cur.(1/5)) (not cur.(2/5)) cur.(3/5) cur.(4/5))) <>
      (assume cur.(0/5) && cur.(1/5) && cur.(2/5) && not cur.(3/5);
          (5 (not cur.(0/5)) (not cur.(1/5)) (not cur.(2/5)) (not cur.(3/5)) cur.(4/5))) <>
      (assume cur.(0/5) && cur.(1/5) && cur.(2/5) && cur.(3/5) && not cur.(4/5);
          (5 (not cur.(0/5)) (not cur.(1/5)) (not cur.(2/5)) (not cur.(3/5)) (not cur.(4/5)))) <>
      (assume cur.(0/5) && cur.(1/5) && cur.(2/5) && cur.(3/5) && cur.(4/5);
          (5 false false false false false));;

let f : [Bool,Bool,Bool,Bool,Bool] -> [] =
  fun (cur : [Bool,Bool,Bool,Bool,Bool]) ->
    (assume cur.(0/5) && cur.(1/5) && cur.(2/5) && cur.(3/5) && cur.(4/5); fail([])) <>
    (f (next cur));;

let b : Bool = true <> false in
(* assume (b && not b); *)
f (5 false false false false false)

